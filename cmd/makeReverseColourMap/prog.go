package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/nickwells/colour.mod/colour"
)

const (
	startComment = "// START:makeReverseColourMap"
	endComment   = "// END:makeReverseColourMap"
)

// Prog holds program parameters and status
type Prog struct {
	exitStatus int

	filename string
	fd       *os.File

	knownMisspellings map[string]bool
}

// NewProg returns a new Prog instance with the default values set
func NewProg() *Prog {
	return &Prog{
		knownMisspellings: map[string]bool{
			"rococco red": true, // nolint:misspell
		},
	}
}

// SetExitStatus sets the exit status to the new value. It will not do this
// if the exit status has already been set to a non-zero value.
func (prog *Prog) SetExitStatus(es int) {
	if prog.exitStatus == 0 {
		prog.exitStatus = es
	}
}

// ForceExitStatus sets the exit status to the new value. It will do this
// regardless of the existing exit status value.
func (prog *Prog) ForceExitStatus(es int) {
	prog.exitStatus = es
}

// Run is the starting point for the program, it should be called from main()
// after the command-line parameters have been parsed. Use the setExitStatus
// method to record the exit status and then main can exit with that status.
func (prog *Prog) Run() {
	var err error
	prog.fd, err = os.OpenFile(prog.filename, os.O_RDWR, 0o755)
	if err != nil {
		fmt.Printf("Couldn't open the program file %q: %s",
			prog.filename, err)
		prog.SetExitStatus(1)
		return
	}
	defer prog.fd.Close()

	prog.PopulateMap()
}

// PopulateMap reads the open file and searches for the first line with the
// start-comment. It notes the position and then searches for the
// corresponding end-comment. Everything from the end-comment (inclusive) to
// the end of the file is copied into a buffer. Then it will go back to the
// recorded position of the start-comment and write the new contents into the
// file. Finally if writes the recorded contents of the file after the
// end-comment to the file and Trancates the file to the new size. It is an
// error if the start or end comments are not found.
//
// Note that the file is searched naively for a string matching the comments,
// it is not parsed.
func (prog *Prog) PopulateMap() {
	scanner := bufio.NewScanner(prog.fd)

	startOffset, startFound := prog.findStart(scanner)
	if !startFound {
		prog.SetExitStatus(1)
		fmt.Println("the start comment was not found")
		fmt.Println("ABORTING")
		return
	}

	endBuffer, endFound := prog.findEnd(scanner)
	if !endFound {
		prog.SetExitStatus(1)
		fmt.Println("the end comment was not found")
		fmt.Println("ABORTING")
		return
	}

	_, err := prog.fd.Seek(startOffset, 0)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot seek to the start point: ", err)
		fmt.Println("ABORTING")
		return
	}

	err = prog.writeMapContents()
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot write the map contents: ", err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")
		return
	}

	_, err = endBuffer.WriteTo(prog.fd)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot write the file contents after the end comment: ",
			err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")
		return
	}

	fileSize, err := prog.fd.Seek(0, 1)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot find the new file size: ", err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")
		return
	}

	err = prog.fd.Truncate(fileSize)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot resize the file: ", err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")
		return
	}
}

// writeMapContents writes the colour map entries to the file.
func (prog *Prog) writeMapContents() error {
	_, err := fmt.Fprintln(prog.fd,
		"\t// Code generated by makeReverseColourMap; DO NOT EDIT.")
	if err != nil {
		return err
	}

	cnm, idxKeys := getColoursByIdx()
	for _, idx := range idxKeys {
		_, err := fmt.Fprintf(prog.fd, "\t0x%06x: {\n", idx)
		if err != nil {
			return err
		}

		// collect the values and sort them so that we get the same order
		// every time
		qcnVals := cnm[idx]
		sort.Slice(qcnVals, func(i, j int) bool {
			if qcnVals[i].Family == qcnVals[j].Family {
				return qcnVals[i].ColourName < qcnVals[j].ColourName
			}
			return qcnVals[i].Family < qcnVals[j].Family
		})

		for _, qcn := range qcnVals {
			noLintComment := ""
			if prog.knownMisspellings[qcn.ColourName] {
				noLintComment = " // nolint:misspell"
			}
			_, err := fmt.Fprintf(prog.fd,
				"\t\t{%s, %q},%s\n",
				qcn.Family.Literal(),
				qcn.ColourName,
				noLintComment)
			if err != nil {
				return err
			}
		}
		fmt.Fprintln(prog.fd, "\t},")
	}
	return nil
}

// getColoursByIdx returns the map of colour index values to qualified names
// and a set of keys in order to access the map in a predictable order.
func getColoursByIdx() (map[uint32][]colour.QualifiedColourName, []uint32) {
	cnm := map[uint32][]colour.QualifiedColourName{}

	for _, ifn := range colour.NamesByIndex() {
		v := cnm[ifn.Idx]
		v = append(v,
			colour.QualifiedColourName{
				Family:     ifn.Family,
				ColourName: ifn.ColourName,
			})
		cnm[ifn.Idx] = v
	}

	idxKeys := []uint32{}
	for k := range cnm {
		idxKeys = append(idxKeys, k)
	}
	sort.Slice(idxKeys, func(i, j int) bool { return idxKeys[i] < idxKeys[j] })

	return cnm, idxKeys
}

// findStart finds the location of the end of the start comment
func (prog *Prog) findStart(scanner *bufio.Scanner) (int64, bool) {
	var startOffset int64
	var startFound bool
	for scanner.Scan() {
		startOffset += int64(len(scanner.Bytes()) + 1) // add 1 for the newline
		if strings.HasSuffix(scanner.Text(), startComment) {
			startFound = true
			break
		}
	}
	return startOffset, startFound
}

// findEnd returns the contents of the file from the end comment
func (prog *Prog) findEnd(scanner *bufio.Scanner) (bytes.Buffer, bool) {
	var endBuffer bytes.Buffer
	var endFound bool
	for scanner.Scan() {
		if strings.HasSuffix(scanner.Text(), endComment) {
			endFound = true
		}
		if endFound {
			endBuffer.WriteString(scanner.Text() + "\n")
		}
	}
	return endBuffer, endFound
}
