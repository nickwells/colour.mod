package main

import (
	"bufio"
	"bytes"
	"fmt"
	"maps"
	"os"
	"slices"
	"sort"
	"strings"

	"github.com/nickwells/colour.mod/colour"
)

const (
	startComment = "// START:makeReverseColourMap"
	endComment   = "// END:makeReverseColourMap"
)

const executablePerms = 0o755

// Prog holds program parameters and status
type Prog struct {
	exitStatus int

	filename string
	fd       *os.File

	knownMisspellings map[string]bool
}

// NewProg returns a new Prog instance with the default values set
func NewProg() *Prog {
	return &Prog{
		knownMisspellings: map[string]bool{
			"aluminum": true, //nolint:misspell

			"beveled glass": true, //nolint:misspell

			"chili":        true, //nolint:misspell
			"chili oil":    true, //nolint:misspell
			"chili pepper": true, //nolint:misspell

			"harbor blue":  true, //nolint:misspell
			"harbor gray":  true, //nolint:misspell
			"harbor mist":  true, //nolint:misspell
			"quiet harbor": true, //nolint:misspell

			"rococco red": true, //nolint:misspell

			"vapor blue": true, //nolint:misspell
		},
	}
}

// SetExitStatus sets the exit status to the new value. It will not do this
// if the exit status has already been set to a non-zero value.
func (prog *Prog) SetExitStatus(es int) {
	if prog.exitStatus == 0 {
		prog.exitStatus = es
	}
}

// ForceExitStatus sets the exit status to the new value. It will do this
// regardless of the existing exit status value.
func (prog *Prog) ForceExitStatus(es int) {
	prog.exitStatus = es
}

// Run is the starting point for the program, it should be called from main()
// after the command-line parameters have been parsed. Use the setExitStatus
// method to record the exit status and then main can exit with that status.
func (prog *Prog) Run() {
	var err error

	prog.fd, err = os.OpenFile(prog.filename, os.O_RDWR, executablePerms)
	if err != nil {
		fmt.Printf("Couldn't open the program file %q: %s",
			prog.filename, err)
		prog.SetExitStatus(1)

		return
	}

	defer prog.fd.Close()

	prog.PopulateMap()
}

// PopulateMap reads the open file and searches for the first line with the
// start-comment. It notes the position and then searches for the
// corresponding end-comment. Everything from the end-comment (inclusive) to
// the end of the file is copied into a buffer. Then it will go back to the
// recorded position of the start-comment and write the new contents into the
// file. Finally if writes the recorded contents of the file after the
// end-comment to the file and Trancates the file to the new size. It is an
// error if the start or end comments are not found.
//
// Note that the file is searched naively for a string matching the comments,
// it is not parsed.
func (prog *Prog) PopulateMap() {
	scanner := bufio.NewScanner(prog.fd)

	startOffset, startFound := prog.findStart(scanner)
	if !startFound {
		prog.SetExitStatus(1)
		fmt.Println("the start comment was not found")
		fmt.Println("ABORTING")

		return
	}

	endBuffer, endFound := prog.findEnd(scanner)
	if !endFound {
		prog.SetExitStatus(1)
		fmt.Println("the end comment was not found")
		fmt.Println("ABORTING")

		return
	}

	_, err := prog.fd.Seek(startOffset, 0)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot seek to the start point: ", err)
		fmt.Println("ABORTING")

		return
	}

	err = prog.writeMapContents()
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot write the map contents: ", err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")

		return
	}

	_, err = endBuffer.WriteTo(prog.fd)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot write the file contents after the end comment: ",
			err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")

		return
	}

	fileSize, err := prog.fd.Seek(0, 1)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot find the new file size: ", err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")

		return
	}

	err = prog.fd.Truncate(fileSize)
	if err != nil {
		prog.SetExitStatus(1)
		fmt.Println("cannot resize the file: ", err)
		fmt.Println("Note: the file may be corrupted")
		fmt.Println("    : consider restoring from backups")
		fmt.Println("ABORTING")

		return
	}
}

// writeMapContents writes the colour map entries to the file.
func (prog *Prog) writeMapContents() error {
	_, err := fmt.Fprintln(prog.fd,
		"\t// Code generated by makeReverseColourMap; DO NOT EDIT.")
	if err != nil {
		return err
	}

	cnm, idxKeys := getColoursByIdx()
	for _, idx := range idxKeys {
		_, err := fmt.Fprintf(prog.fd, "\t0x%06x: {\n", idx)
		if err != nil {
			return err
		}

		// collect the values and sort them so that we get the same order
		// every time
		qcnVals := cnm[idx]
		sort.Slice(qcnVals, func(i, j int) bool {
			if qcnVals[i].Family == qcnVals[j].Family {
				return qcnVals[i].ColourName < qcnVals[j].ColourName
			}

			return qcnVals[i].Family < qcnVals[j].Family
		})

		for _, qcn := range qcnVals {
			noLintComment := ""
			if prog.knownMisspellings[qcn.ColourName] {
				noLintComment = " //nolint:misspell"
			}

			_, err := fmt.Fprintf(prog.fd, "\t\t{%s, %q},%s\n",
				qcn.Family.Literal(), qcn.ColourName, noLintComment)
			if err != nil {
				return err
			}
		}

		fmt.Fprintln(prog.fd, "\t},")
	}

	return nil
}

// getColoursByIdx returns the map of colour index values to qualified names
// and a set of keys in order to access the map in a predictable order.
func getColoursByIdx() (map[uint32][]colour.QualifiedColourName, []uint32) {
	cnm := map[uint32][]colour.QualifiedColourName{}

	for _, ifn := range colour.NamesByIndex() {
		v := cnm[ifn.Idx]
		v = append(v,
			colour.QualifiedColourName{
				Family:     ifn.Family,
				ColourName: ifn.ColourName,
			})
		cnm[ifn.Idx] = v
	}

	return cnm, slices.Sorted(maps.Keys(cnm))
}

// findStart finds the location of the end of the start comment
func (prog *Prog) findStart(scanner *bufio.Scanner) (int64, bool) {
	var startOffset int64

	var startFound bool

	for scanner.Scan() {
		startOffset += int64(len(scanner.Bytes()) + 1) // add 1 for the newline

		if strings.HasSuffix(scanner.Text(), startComment) {
			startFound = true
			break
		}
	}

	return startOffset, startFound
}

// findEnd returns the contents of the file from the end comment
func (prog *Prog) findEnd(scanner *bufio.Scanner) (bytes.Buffer, bool) {
	var endBuffer bytes.Buffer

	var endFound bool

	for scanner.Scan() {
		if strings.HasSuffix(scanner.Text(), endComment) {
			endFound = true
		}

		if endFound {
			endBuffer.WriteString(scanner.Text() + "\n")
		}
	}

	return endBuffer, endFound
}
